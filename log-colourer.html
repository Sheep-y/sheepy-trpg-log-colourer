<!DOCTYPE html><html><head>
   <meta charset="utf-8" />
   <meta name="viewport" content="width=device-width, initial-scale=1" />
   <link id="icon" rel="icon" href="data:image/gif,GIF89a%40%00%40%00%E7%BD%00%3B%00%9F2%03%A4%3D%00%A6%3C%01%A0B%00%99%3E%00%A73%04%A5%3E%02%A15%05%A6%3B%05%98%3C%06%99%2B%0A%ACA%07%8DS%00%A3%3D%08%9A-%0C%ADY%05%9Ad%02%9Fy%00%AAq%03%A7%81%02%88%83%00%96%1B%1C%B9%81%00%A9%84%01%97%87%00%AB%85%00%B1%86%00%B3%89%00%AC%87%00%B4%8A%00%AD%82%03%AA%83%05%AB%84%08%AC%1B%26%C9%A2%12I%9A%15E%9C%16B%17%2F%D7%A3%14J%9B%17F%A5%16K%A6%18L%9F%1BI%98%1EF%A7%19M%AA%1AD%00%3F%F2%CD%17*%B9%1D7%00F%FF%00G%F8%00G%F9%D3%1E%22%12B%F7%00G%FF%12B%FF%00H%FA%00I%F2%00I%F4%00H%FF%00I%FF%1EE%FA%20F%F4%FF%1D%0A%ED%23%13%FF%1E%15%F7!%0F%FF%20%0B%F9%23%11%F0%26%15%FA%25%12%F1(%16%FB'%13%F2*%17%FD)%08%FD)%14%F5-%0F%EF2%0B%F2%3F%03%ECB%0D%00%7B%B8%F3H%06%E6L%0B%E7N%0D%F7K%0B%FFL%05%00%84%CE%F3P%09%F4Q%0B%FCP%01%F7S%00%FDQ%03%08%87%BE%0D%86%C4%FFR%05%FFS%07!%84%B6%00%8E%CB%00%90%CD%04%92%AF%17%8B%C2%02%91%CE%15%8D%BE%07%92%D0%1A%8F%C0%1E%8E%C5%1F%97%83O%96CJ%A1X%5B%A32%60%A6-b%A7.%EE%84%00e%AA1f%AB2%60%AD3g%AC3c%AE%2Ck%AD%22d%AF-%E5%8E%00e%B0.r%AD-l%AF.%E9%91%08%F0%91%00%ED%95%00%EC%94%0D%E7%96%0B%F4%94%00%EE%96%00%F5%95%01%F6%96%03%FC%95%08%F8%97%06%E4%9E%00%F9%98%00%EF%9C%02%FB%99%00%D9%A5%00%8C%BC%22%DC%A8%00%DE%A9%01%E0%AB%06%90%C0'%E7%AB%00%E3%AD%00%EE%AB%00%E5%AF%00%EE%B1%01%EF%B2%04%F3%B5%00%F4%B6%00%F5%B7%00%EB%BA%0C%F2%BA%00%F8%B9%00%FA%BB%02%B6%CD(%FC%BC%05%FD%BD%00%AE%D4%2B%C0%D6'%C2%D8*%EE%CE%14%C5%DC.%C8%DD%22%C9%DE%24%CA%DF%26%EB%D7%1D%C7%E3(%C8%E4*%CC%E7%20%CF%E9%24%D0%EA%25%D1%EB'%D2%ED)%F3%F1%2C%F4%F2.%F6%F3%2F%F3%F72%F4%F83%F7%FA(%F9%FB*%FA%FC%2C%FB%FD-%FC%FE%2F%FD%FF1%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00!%F9%04%01%0A%00%FF%00%2C%00%00%00%00%40%00%40%00%40%08%FE%00%FF%09%1CH%B0%A0%C1%83%08%13*%5C%C8P%20%09%15%10!%AE%20X%84H%12%22%181%26)B%90%CA%160%20A6D%F8%A1%A4%C9%93%1F*%A8%5CIad%C180c%E6%E9C%B3%A6%CD%91%1F6%E8%DC%A9%D3eCA%8B%82%0A%5D%24H%E1%81%00%02%90%0AX%BA%14%A9%05%9FP%09v%9AJ%B5*%A8N%8C%12%FA%B8%C1%B5%2BW%1DQ%13%EA%DAE%B6%2C%D9%B0%06%A3xY%BB%F6%0A%1B8p%E3%CA%9D%0B%C7%CD'T%A7%F2%9EJ%85%96a%174%80%D1%841%A8%07%8F%9E%C3%88%0F%B2z%E5%EA%15%AC%BE%90%07Z%BC%C81r%DF%87%11%23%9E%08%92%B1s%E7%25D%A0%84%1C%0D%26r%08%9E%A8wZ%1E%CAz%E8%C8%03L%1B%EC%FC%609%A1PETA%3Dz-%E0%80%09%AF%B5%0F%E2%22%AB%8B%16%26P%98*%8D%F4%CA%DC%EB%8C%C8f%A3%9B%BD%05%F9o%E0%EBk%0C%23%DE%8ExO%E3W%E0%C3%FE%3F%0E%1E%D6Nb%F2%E8%0B%26I%92%3E%EA%C3%14(%12%82%EE%5C%F9%60%16%91%ED%FFa%CE%0Cq%84%12%CF%9E%25!%05i%A3%E5%A7%1F%7F*%B8P%84%10%006%98%C4%13%04%96%D6%17%07%A9U%B8%01mh%B5%A6aP8Y%D8Sm%40m%B8HT%10%A0%C6A%7B!%0A5HC%09%24%C5%14S%07p%80%A1%81%FF%2C%82H(UM%85%DCA%0E%C0%A6To%22pE%E3%3F%B7%F0%22%0B'9vb%C9H34%D7%5E.c%11%B7KT%CD1%07%96e%BBD%19%DDX%CBU%E9%25Z%B5H'%26Y%B6%F4e%DDuh%B4Q%18wl%EA%C1%C7*%DF%89g%E0%99%D7%95!%90vm%D6%F1%CF(%E0%C5%E9%D8%9Cb%2Cd%07%9Ex%2CDJ%2CC64h%A2%E4%15%C1%1E%A3%96%FDG%C4%12%90%26D%02%0B%0B%1Dq%91F%0Cia%E0~%13%19%B4iF%17%1DDE%81%F9%ED%97%19%A6%FF%8C%0A%A0%11%FE%02%DDG%E0%A7%08B%14%83%10%AE%02%E8D%84%F8%B5%A7jD0%10%C1%60%83%9D5%A1E%84%06%96%E0%C2%B2%CB%AAP%03%B1%C4%16Q%05iV%F4%95%93%87%A9%A1u%88%88%AD%1D%B2%D0%B5%D8n%10%02d)r%EBmC%E1%8E%1B%19%20%DC.%B2%A2K%1E%CE%B8%DA%86~DE!j%F2%D6%A6aT%0A%1C%25%01O%06n%1B%94%20%94%80%A2%1CCG%B9%18%40%00%13%7C%18%F0%22%86Xb%15%26%90%14%D4%AF%8B%2F%BA%18%01%A3%81%24%99%23%26%04%FD%98q%00%2F%5CI%E3.%9B%5C%E5%B1%23%08%11%80%F1%03%5D%99%DC%9E.c%95%92%A3K%0C%2C%C0%5C%0E%F9eI%16%2F%AAH%12V%95%CF%917%8B%98%B5%40%A5%83%977%F8%10%DC-c%EE%92%8BK%3F0%DD%95e%C3E-uC9X%0D%5C_Pj%9D%E5%D4%0Ay%8D%C3%D9h%DB%10%16%2Fl%B7%ED%F6%DBl%9B%89%26%1Ad%D0%D1f%9Bx4%12KNx%E0%8D%D7%1E%9D%81%9Dq%C7%DD%88%E1%81G%24%8C%F1%FDg~%80%07%96%86%DDw%1B.%8A%E2r2%8E%E6%18%83%09%049wx%D8A%D0b%7C%FB%9D%9Euj%20%24%07%9B%85%1EDJ%2B%8BWJ%98vt%B8%DE%97as%C8n%7BC%01%01%00%3B" />
   <!-- Colour Star from Wikipedia Common created by AI2 2007-2010, licensed under GNU Free Documentation License / Creative Commons Attribution-Share Alike 3.0 Unported -->
   <title> IRC Log Colourer by Sheepy </title>
<style>
   * {
      box-sizing: border-box;
      -moz-box-sizing: border-box;
      -webkit-box-sizing: border-box;
   }
   html, body { margin: 0; padding: 0; height: 100%; }
   body  {
      background-color: #DDD;
      background-image: -moz-linear-gradient( 280deg, #FDD, #FED, #FFC, #DFD, #DFE, #DDF, #FCF );
      background-image: linear-gradient( 350deg, #FDD, #FED, #FFC, #DFD, #DFE, #DDF, #FCF );
   }
   h1 {
      margin-top: 0;
      padding-top: 1ex;
      font: bold 24px serif;
   }
   body > div {
      display: none;
      margin: 0;
      padding: 0;
      padding-bottom: 72px;
   }
   textarea {
      width: 100%;
      height: 350px;
      background-color: white;
      resize: vertical;
   }

   #lst_colour > span {
      display: inline-block;
      min-width: 5em;
      padding: 0 1ex;
   }
   select {
      width: 8em;
      background-color: transparent;
   }

   #txt_output {
      background-color: transparent;
   }

   .button {
      font: bold 24px sans-serif;
      display: inline-block;
      text-decoration: none;
      color: black;
      padding: 1ex;
      border: 2px outset #888;
      background-color: rgba( 255, 255, 255, 0.5 );
   }
   .button:hover {
      color: blue;
      background-color: rgba( 255, 255, 255, 0.9);
   }

   .footer {
      position: fixed;
      width: 100%;
      bottom: 0;
   }
   .footer a {
      width: 50%;
      text-align: center;
   }
</style>
</head><body>

<img id='header_image' style='float:left; height: 32px; margin: 1ex'/>
<h1 class="header">  </h1>

 <div id="action_input">
   <p class="lbl_message"></p>
   <textarea id="txt_input"></textarea>
   <div class="footer">
      <a class='button' href="javascript:switch_action('output')" id='action_input_btn_output'> btn_output </a><!--
   --><a class='button' href="javascript:switch_action('colour')" id='action_input_btn_next'> btn_next </a>
   </div>
</div>

<div id="action_colour">
   <p class="lbl_message"></p>
   <div id="lst_colour"></div>
   <a class='button' href='javascript:reset_colour()' id='action_colour_btn_reset'>btn_rest</a>
   <div class="footer">
      <a class='button' href="javascript:switch_action('input')" id='action_colour_btn_back'> btn_back </a><!--
   --><a class='button' href="javascript:switch_action('preview')" id='action_colour_btn_next'> btn_next </a>
   </div>
</div>

<div id="action_preview">
   <p class="lbl_message"></p>
   <pre id="pre_preview"></pre>
   <div class="footer">
      <a class='button' href="javascript:switch_action('colour')" id='action_preview_btn_back'> btn_back </a><!--
   --><a class='button' href="javascript:switch_action('output')" id='action_preview_btn_next'> btn_next </a>
   </div>
</div>

<div id="action_output">
   <p class="lbl_message"></p>
   <textarea id="txt_output"></textarea>
   <div class="footer">
      <a class='button' href="javascript:switch_action('preview')" id='action_output_btn_back'> btn_back </a><!--
   --><a class='button' href="javascript:switch_action('input')" id='action_output_btn_restart'> btn_restart </a>
   </div>
</div>

<script>"strict mode";
//(function main(){

/*****************************************************************
 * Text
 *****************************************************************/
var txt = {};
txt.en = {
  title: 'IRC Log Colourer v2 Alpha by Sheepy',
  err_upgrade: 'Please upgrade browser',
  action_input: {
     lbl_parsing : 'Detecting names...',
     lbl_parsed  : 'People: ',
     btn_output : 'Output >>',
     btn_next   : 'Colouring >',
     err_nolog : 'Please input log first.',
     err_date  : 'Cannot parse date time.',
     err_parse : 'Cannot parse names.',
     err_noname: 'Cannot progress without identifying speakers.'
  },
  action_colour: {
     btn_reset : 'Reset to default',
     btn_back  : '< Input',
     btn_next  : 'Preview >',
  },
  action_preview: {
     btn_back  : '< Colouring',
     btn_next  : 'Output >',
  },
  action_output: {
     btn_back    : '< Preview',
     btn_restart : '<< Restart',
  },
  colour: {
    colours: [
      ''       , ' '      , '#C50'   , 'orange' ,
      'olive'  , 'green'  , 'teal'   , 'blue'   ,
      'navy'   , '#50C'   , 'purple' , 'maroon' ,
      'red'    , 'fuchsia', 'yellow' , 'lime'   ,
      'aqua'   , '#F88'   , 'black'  , '#333'   ,
      'gray'   , 'silver' , 'white'
    ],
    names: [
      'As name', '(None)' , 'Dare Orange', 'Orange'  ,
      'Olive'  , 'Green'  , 'Teal'   , 'Blue',
      'Navy'   , 'Indigo' , 'Purple' , 'Maroon',
      'Red'    , 'Fuchsia', 'Yellow' , 'Lime',
      'Aqua'   , 'Coreal' , 'Black'  , 'Light grey',
      'Grey'   , 'Silver' , 'White'
    ],
    auto: [
      '#C50'   ,
      'orange' ,
      'olive'  ,
      'green'  ,
      'teal'   ,
      'blue'   ,
      'navy'   ,
      '#50C'   ,
      'purple' ,
      'maroon' ,
      'fuchsia'
    ],
    dm: {
      name: 'silver',
      colour: 'red'
    },
    bot: {
      name: 'red',
      colour: ' '
    },
  }
};
txt.zh = {
  title: 'Sheepy 的 IRC 上色器 v2 Alpha',
  err_upgrade: '請升級瀏覽器',
  action_input: {
     lbl_parsing : '偵察名字中...',
     lbl_parsed  : '參與者: ',
     btn_output : '輸出 >>',
     btn_next   : '上色 >',
     err_nolog : '請先輸入記錄。',
     err_date  : '無法解析日期時間。',
     err_parse : '無法解析名字。',
     err_noname: '無法認出參與者，不能繼續。'
  },
  action_colour: {
     btn_reset : '重設成預設',
     btn_back  : '< 輸入',
     btn_next  : '預覽 >',
  },
  action_preview: {
     btn_back  : '< 上色',
     btn_next  : '輸出 >',
  },
  action_output: {
     btn_back    : '< 預覽',
     btn_restart : '<< 重新開始',
  },
  colour: {
    colours: [
      ''       , ' '      , '#C50'   , 'orange' ,
      'olive'  , 'green'  , 'teal'   , 'blue'   ,
      'navy'   , '#50C'   , 'purple' , 'maroon' ,
      'red'    , 'fuchsia', 'yellow' , 'lime'   ,
      'aqua'   , '#F88'   , 'black'  , '#333'   ,
      'gray'   , 'silver' , 'white'
    ],
    names: [
      '同名字'  , '(不上色)','深橙色', '橙色'  ,
      '橄欖色'  , '綠色'   , '青綠色', '淺藍色',
      '藍色'    , '藍祡色' , '祡色'  , '深紫紅',
      '紅色'    , '粉紅色' , '黃色'  , '淺綠色',
      '淺青綠色', '珊瑚色' , '黑色'  , '深灰色',
      '灰色'    , '淺灰色' , '白色'
    ],
    auto: [
      '#C50'   ,
      'orange' ,
      'olive'  ,
      'green'  ,
      'teal'   ,
      'blue'   ,
      'navy'   ,
      '#50C'   ,
      'purple' ,
      'maroon' ,
      'fuchsia'
    ],
    dm: {
      name: 'silver',
      colour: 'red'
    },
    bot: {
      name: 'red',
      colour: ' '
    },
  }
}

/*****************************************************************
 * Non-screen speciifc utilities
 *****************************************************************/


/** Alias for document.querySelectorAll */
function _(css) { return document.querySelectorAll(css); }

/** Show text for given selectors */
function set_text( css, text ) {
   text = irc_to_text( text );
   Array.prototype.forEach.call( _(css), function(e){
      e.textContent = text;
   } );
}

/** Show error message on every page */
function set_message( msg ) {
   set_text( '.lbl_message', msg );
}

/** Trim mIRC control code from text */
function irc_to_text( text ) {
   return text.replace( irc_to_text.pattern, '' );
}
irc_to_text.pattern = /\x03\d\d?(,\d\d?)?/g;

function text_to_html( text ) {
   if ( text && text.replace ) return text.replace( /&/g, '&amp;' ).replace ( /</g, '&lt;' );
   return text;
}

var datePattern;
var nameBoundary;
var nameList = [];
var colourList = { " version": 20120808 };
var log = [];

/**************************************/
/****** MAIN ROUTINE ******************/
/**************************************/
var currentPage = '';

var lang = location.search.match( /[?&]lang=(\w+)($|&)/ );
if ( lang ) {
  lang = lang[1];
} else {
  lang = navigator.language || navigator.userLanguage;
}
if ( lang &&lang.match( /^zh(-.+)?$/ ) ) {
  txt = txt.zh;
} else {
  txt = txt.en;
}

if ( !document.querySelectorAll || !"".trim || ![].filter ) {
   alert( txt.err_upgrade );
   //return;
} else {
   window.addEventListener('DOMContentLoaded',function(){ switch_action('input'); },false);
   set_text( '.header', txt.title );
   document.getElementById('header_image').src = document.getElementById( 'icon' ).href;
   document.title = txt.title;
}

/**
 * Switch between actions. Would find and call action_{$page}_cleanup for current page and action_{$page}_setup for next page.
 */
function switch_action(page) {
   set_message('');

   // Pre-switch validation & cleanup
   var func = 'action_' + currentPage + '_cleanup';
   if ( switch_action[func] && switch_action[func]( page ) === false ) return;

   Array.prototype.forEach.call(_("body > div[id]"), function(e){ e.style.display = 'none'; });
   _("#action_"+page)[0].style.display = 'block';

   // Post-switch setup
   func = 'action_' + page + '_setup';
   if ( switch_action[func] ) switch_action[func]( page );

   currentPage = page;
}



/*****************************************************************
 * Input screen and date + name parsing
 *****************************************************************/

var timer_checkInput = 0;
var lastLog = "";

/**
 * Setup timer that monitors input change
 */
switch_action.action_input_setup = function action_input_setup() {
   set_text( '#action_input_btn_output', txt.action_input.btn_output );
   set_text( '#action_input_btn_next' , txt.action_input.btn_next  );
   function timer_onCheckInput() {
      var log = _('#txt_input')[0].value.trim();
      if ( log !== lastLog ) {
         lastLog = log;
         parse_input();
      }
   }
   timer_onCheckInput();
   timer_checkInput = setInterval( timer_onCheckInput, 500 );
   _('#txt_input')[0].focus();
}

/**
 * Check status and clear timer that monitors input change
 */
switch_action.action_input_cleanup = function action_input_cleanup() {
   if ( log.length <= 1 ) {
      alert( txt.action_input.err_nolog );
      return false;
   }
   if ( nameList.length <= 0 ) {
      alert( txt.action_input.err_noname );
      return false;
   }
   if ( timer_checkInput ) {
      clearInterval(timer_checkInput);
      timer_checkInput = 0;
   }
   colours_load();
}


/**
 * Pre-Process log and then analyse date pattern
 */
function parse_input() {
   datePattern = nameBoundary = null;
   nameList = [];

   log = _('#txt_input')[0].value.trim().split(/\n/g);
   if ( log.length > 1 ) {
      set_message( txt.action_input.lbl_parsing );
      parse_date();

      // Try to identify names - variable with fixed prefix and postfix
      parse_name();

      if ( nameList.length > 0 ) {
         set_message( txt.action_input.lbl_parsed + nameList.concat().reverse().join(', ') );
      } else {
         set_message( datePattern === null ? txt.action_input.err_date : txt.action_input.err_parse );
      }
   } else {
      set_message( '' );
   }
}

/**
 * Parse date pattern from log
 */
function parse_date() {
   // List of candidate patterns for date
   var candidates = []; // [ { pattern: genPattern( log[0] ), text: log[0], count: 0 } ];
   // Number of lines we are scanning
   var lineCount = Math.min( log.length, 500 );

   // Generate a date pattern from given string.
   function genPattern(txt) {
      return new RegExp( "^" + txt.replace( /([-[\]{}()*+?.,\\^$|#])/g, '\\$1' ).replace( /\d{1,2}/g, '\\d{1,2}' ).replace( /am|pm|nn/g, '(am|pm)' ).replace( /AM|PM|NN/g, '(AM|PM)' ).replace( /上午|下午|中午/g, '[上下中]午' ) );
   }
   // Create a new pattern from given line
   function createPattern(i,txt) {
      var newPattern = { pattern: genPattern(txt), text: txt, count: 1 };
      candidates.unshift( newPattern );
      for ( var k = 0 ; k < i ; k++ ) {
         if ( log[k].match( newPattern.pattern ) ) ++newPattern.count;
      }
   }

   // Scan the lines
   for ( var i = 0 ; i < lineCount ; i++ ) {
      var line = log[i];
      var found = false;

      if ( line.trim() === "" ) continue;

      // Scan throgh the candidates
      candidates.forEach( function(e) {
         if ( line.match( e.pattern ) ) {
            ++e.count;
            found = true;
         }
      });

      // If no match, find a new one from shortest match
      if ( ! found && candidates.length > 0 ) {
         // Loop through all candidates we have
         for ( var j = 0 ; j < candidates.length ; j++ ) {
            // Remove characters one by one until we found a match
            var tmp = candidates[j].text;
            do {
               tmp = tmp.substr( 0, tmp.length-1 );
               // If a match is found then use it as new pattern
               if ( line.match( genPattern(tmp) ) ) {
                  createPattern( i, tmp );
                  found = true;
               }
            } while ( tmp.length > 5 && ! found );
            if ( found ) break;
         }
      }

      // If still no match, create a new pattern with this line
      if ( ! found && line.length > 5 ) createPattern( i, line );
   } // for ( var i = 0 ; i < lineCount ; i++ ) {

   // After the lines are scanned, find candidate pattern with highest hit rate.
   if ( candidates.length ) {
      var highest = candidates[0];
      for ( var i = candidates.length -1 ; i > 0 ; i-- ) {
         if ( candidates[i].count > highest.count ) {
            highest = candidates[i];
         } else if ( candidates[i].count == highest.count && candidates[i].text.length > highest.text.length ) {
            highest = candidates[i];
         }
      }
      if ( highest.count >= Math.min( lineCount-1, Math.floor( lineCount*0.95) ) ) {
        datePattern = highest.pattern;
      }
   }
}

/**
 * Parse name pattern from log
 */
function parse_name() {
   // Initialisation
   function find_pattern( proprocess ) {
      var candidates = []; // [ { boundary: /:/, count: 0, nameCount: 0, names: { 'name1': 3 , 'name2': 5 } ] ]
      var special_char = ':]>"\'\t ：］＞　';
      var pattern_count = special_char.length;
      for ( var i = 0 ; i < pattern_count ; i++ ) {
        candidates.push( { boundary: special_char.charAt(i), count: 0, nameCount: 0, names: {} } );
      }

      // Test each boundary on each line of log
      var lineCount = log.length;
      var validLines = 0;
      for ( var i = 0 ; i < lineCount ; i++ ) {
         // Get first part of this line (exlucding date)
         var line = datePattern ? log[i].replace( datePattern, '' ) : log[i];
         // Filter away chanserv / nickserv message and lines without date, then run preprocess and check result
         if ( line.length <= 0 || line.match( /\b(ChanServ|NickServ)\b/i ) ) continue;
         var trimmedLine = proprocess( line.trim().substr( 0, 20 ) );
         if ( !trimmedLine ) continue;

         // Remove leading * and start looping through candidates
         trimmedLine = trimmedLine.replace( /^\*+/, '' );
         ++validLines;

         for ( var j = 0 ; j < pattern_count ; j++ ) {
            // Skip action lines for more accurate detection
            var c = candidates[j];
            var tmp = trimmedLine.substr(1).match( c.boundary );
            if ( tmp ) {
               ++c.count;
               tmp = trimmedLine.substr( 0, tmp.index+1 );
               var namelist = c.names;
               if ( namelist[tmp] ) {
                  ++namelist[tmp];
               } else {
                  ++c.nameCount;
                  namelist[tmp] = 1;
               }
            }
         }

         // After 64 valid lines, remove characters with fewer then 8 hits to speed up scanning
         if ( validLines == 64 ) {
            for ( var j = pattern_count-1 ; j >= 0 ; j-- ) {
               if ( candidates[j].count < 8 ) {
                  candidates.splice(j, 1);
                  --pattern_count;
               }
            }
            if ( pattern_count <= 0 ) break;
         }
      }

      // With the candidates, try to find the best fit
      if ( pattern_count > 0 ) {
         var bestBoundary = candidates[0];
         for ( var j = 1 ; j < pattern_count ; j++ ) {
            var c = candidates[j];
            // Find boundary with highest line ratio
            if ( bestBoundary.count <= 0 || ( c.count / c.nameCount ) > ( bestBoundary.count / bestBoundary.nameCount ) ) {
               bestBoundary = c;
            }
         }
         var names = [];
         for ( var name in bestBoundary.names ) {
            if ( name !== "" ) names.push( name.replace(/^[<(\[]/, '').replace( /\d+$/, '' ).trim() );
         }
         return names;
      }
   }

   /**
    * Sort by reverse text length, then by text content.
    * Sorting in reverse make sure that longer names are detected first
    */
   function rev_length_sort(a, b) {
      var dl = b.length - a.length;
      if ( dl != 0 ) return dl;
      return a < b ? 1 : -1;
   }

   // Parse names from normal lines
   var a = find_pattern( function(line){ return line.indexOf('*') === 0 ? null : line } );
   // Parse names from action lines (lines starting with *)
   a = a.concat( find_pattern( function(line){ return line.indexOf('*') !== 0 ? null : line } ) );
   // remove duplicates then sort by reverse length
   nameList = a.filter( function(e,i){ return e !== "" && a.indexOf(e) === i } );
   nameList.sort( rev_length_sort );
}


/*****************************************************************
 * Colour selection screen
 *****************************************************************/

/**
 * Lost colour settings, setup colour select boxes, assign initial colours if necessary
 */
switch_action.action_colour_setup = function action_colour_setup() {
   set_text( '#action_colour_btn_back' , txt.action_colour.btn_back );
   set_text( '#action_colour_btn_next' , txt.action_colour.btn_next );
   set_text( '#action_colour_btn_reset', txt.action_colour.btn_reset );

   var list = _('#lst_colour')[0];
   var tbl = document.createElement( 'table' );
   var tby = document.createElement( 'tbody' );
   list.innerHTML = '';
   list.appendChild( tbl );
   tbl.appendChild( tby );
   nameList.forEach( function( name ) {
      var c = colourList[name];
      var tr = document.createElement( 'tr' );
      var td = document.createElement( 'td' );
      tby.appendChild( tr );
      td.appendChild( document.createTextNode( name ) )
      tr.appendChild( td );
      var td = document.createElement( 'td' );
      td.appendChild( create_colour_select( find_colour_index( c.name   ), false, function(value){ colourList[name].name   = value; colours_save(); } ) );
      tr.appendChild( td );
      var td = document.createElement( 'td' );
      td.appendChild( create_colour_select( find_colour_index( c.colour ), true , function(value){ colourList[name].colour = value; colours_save(); } ) );
      tr.appendChild( td );
   });
}

/**
 * Clean up select boxes and save colour settings
 */
switch_action.action_colour_cleanup = function action_colour_cleanup() {
   _('#lst_colour')[0].innerHTML = '';
   colours_save();
}

function reset_colour() {
   colourList = {};
   colours_fill();
   switch_action.action_colour_setup('colour');
}

/**
 * Load saved colours
 */
function colours_load() {
   if ( document.cookie ) {
      try {
         colourList = JSON.parse( decodeURI( document.cookie ) );
      } catch ( e ) {
         if ( window.console ) console.log( "Cannto read past colours from cookie: "+e );
      }
   }
   colours_fill();
}

/**
 * Fill unset users with default colour
 */
function colours_fill() {
   var special_users;
   nameList.forEach( function( name ) {
      // If new name, try to determine whether his/her colour
      if ( ! colourList[name] ) {
         // Find DM and bots
         if ( special_users === undefined ) special_users = find_special_users();
         colourList[name] = {
            name: '',
            colour: '',
            select: null
         };

         if ( name === special_users.dm ) {
            // Game Master (the one who speak most)
            colourList[name] = {}
            for ( var prop in txt.colour.dm ) colourList[name][prop] = txt.colour.dm[prop];

         } else if ( special_users.bots.indexOf( name ) >= 0 ) {
            // Bots
            colourList[name] = {}
            for ( var prop in txt.colour.bot ) colourList[name][prop] = txt.colour.bot[prop];

         } else {
            // Normal users, pick colour from name hash
            var colour = name.charCodeAt(0);
            for ( var i = 1 ; i < name.length ; i++ ) colour = ( colour << 2 ) + name.charCodeAt(i);
            colourList[name].colour = txt.colour.auto[ colour % txt.colour.auto.length ];
         }
      }
   } );
}

/**
 * Save current colours
 */
function colours_save() {
   document.cookie = encodeURI( JSON.stringify( colourList ) );
}

/**
 * Given a colour, find the index in colour select list
 */
function find_colour_index( colour ) {
   var result = txt.colour.colours.indexOf( colour );
   return result < 0 ? 1 : result;
}

/**
 * Find DM and dicebots
 */
function find_special_users() {
   var dm = nameList[0];
   var bots = [];
   var count = 0;
   nameList.forEach( function( name ) {
      // Detect robots
      var lc = name.toLowerCase();
      if ( lc === 'dicebot' || lc == 'dndbot' || name.match( /[a-z]Bot$/ ) ) {
         bots.push( name );
      } else {
        // Not bot; detect DM
        var hit = 0;
        var lastline = -2;
        log.forEach( function( line, i ) {
           var i = line.indexOf( name );
           if ( i > 0 && i < 20 ) {
              ++hit;
              if ( lastline == i+1 ) hit += 0.5; // Heavier weight to continuous lines
              lastline = i;
           }
        } );

        // If this one spoke more then current DM candidate, make it current DM candidate
        if ( hit > count ) {
           dm = name;
           count = hit;
        }
     }
   } );

   return { dm: dm, bots: bots };
}

/**
 * Create a colour selection box
 */
function create_colour_select( index, canBlank, onChange ) {

   // Create an <option> for a colour
   function create_colour_option( index ) {
      var opt = document.createElement('option');
      opt.setAttribute('value', txt.colour.colours[index] );
      opt.textContent = txt.colour.names[index]
      opt.style.color = txt.colour.colours[index]; // Bug: blank would use existing colour
      return opt;
   }

   // Create the select box
   var sel = document.createElement('select');
   var opt = create_colour_option( index );
   sel.appendChild( opt );
   sel.style.color = opt.style.color;

   // When clicked, expand colour options then remove this event handler
   function colour_select_onMouseDown ( event ) {
      // Insert colours before current option
      for ( var i = canBlank ? 0 : 1 ; i < index ; i++ ) {
         var co = create_colour_option( i );
         sel.insertBefore( co, opt );
      }
      // Insert colours after current option
      for ( var i = index+1 ; i < txt.colour.colours.length ; i++ ) {
         sel.appendChild( create_colour_option( i ) );
      }
      this.removeEventListener( 'mousedown', colour_select_onMouseDown, false );
   }
   sel.addEventListener( 'mousedown', colour_select_onMouseDown, false );

   // When changed, update select box's colour
   sel.addEventListener( 'change', function() {
      sel.style.color = sel.value;
      if ( onChange ) onChange( sel.value );
   }, false );

   return sel;
}


/*****************************************************************
 * Preview screen
 *****************************************************************/

/**
 * Apply preview
 */
switch_action.action_preview_setup = function action_preview_setup() {
   set_text( '#action_preview_btn_back', txt.action_preview.btn_back );
   set_text( '#action_preview_btn_next', txt.action_preview.btn_next );
   _('#pre_preview')[0].innerHTML = generate_output( html_builder );
}

/**
 * Clean up preview
 */
switch_action.action_preview_cleanup = function action_preview_cleanup() {
   _('#pre_preview')[0].innerHTML = '';
}


/*****************************************************************
 * Output screen
 *****************************************************************/

/**
 * Apply preview
 */
switch_action.action_output_setup = function action_output_setup() {
   set_text( '#action_output_btn_back', txt.action_output.btn_back );
   set_text( '#action_output_btn_restart', txt.action_output.btn_restart );
   _('#txt_output')[0].value = generate_output( bbc_builder );
   _('#txt_output')[0].focus();
   _('#txt_output')[0].select();
}

/**
 * Clean up preview
 */
switch_action.action_output_cleanup = function action_output_cleanup() {
   _('#txt_output')[0].value = '';
}


/**
 * Build output from log variable, coloutList variable, and from builder parameter
 */
function generate_output( builder ) {
   var result = '';
   var leadingUnnamed = true;

   if ( builder.open )  result += builder.open();

   log.forEach( function( line ) {
      if ( ! line.match( /\b(ChanServ|NickServ)\b/i ) ) {
        line = line.trim();

        var buffer = '';
        var actor = '';
        var index = line.length;
        // Determine actor of this line
        nameList.forEach( function( name ) {
          var pos = line.indexOf( name );
          if ( pos >= 0 && pos < index ) {
             actor = name;
             index = pos;
          }
        } );

        // Call builder tp
        var tmp = line.match( datePattern );
        if ( actor ) {

           // As soon as we found a name, unnamed leading part ends
           leadingUnnamed = false;

           // Start building line
           if ( builder.mark ) builder.mark();
           var dateLen = 0;
           if ( tmp ) {
              tmp = tmp[0];
              buffer += builder.build_line( 'silver', tmp );
              dateLen = tmp.length;
           }
           if ( actor ) {
              var tmp2 = line.substr( dateLen, index-dateLen+actor.length+1 );
              // Discard lines start with .r .roll .rh .here etc.
              if ( line.substr( dateLen + tmp2.length ).match( /^\s*\.\w\s+[d\d]/ ) ) {
                 if ( builder.reset ) builder.reset();
                 buffer = "";
              } else {
                 if ( actor && colourList[actor] && colourList[actor].colour ) {
                    // Coloured, output coloured line
                    buffer += builder.build_line( colourList[actor].name, tmp2 );
                    buffer += builder.build_line( colourList[actor].colour, line.substr( dateLen + tmp2.length ) );
                 } else {
                    // No colour, output normal line
                    buffer += builder.build_line( colourList[actor].name, line.substr( dateLen ) );
                 }
              }
           } else {
              // No actor, output normal line
              buffer += builder.build_line( null, line.substr( dateLen ) );
           }
        } else {
           // If still in leading section, build this line
           if ( leadingUnnamed ) {
              if ( tmp ) {
                 buffer = builder.build_line( 'silver', tmp[0] );
                 buffer += builder.build_line( '', line.substr( tmp[0].length ) );
              } else {
                 buffer = builder.build_line( '', line );
              }
           }
        }

        // If line is valid, append to buffer
        if ( buffer ) {
           buffer += "\n";
           result += buffer;
        }
      }
   } );

   if ( builder.close )  result += builder.close();

   return result;
}


/**
 * Build line in HTML
 */
var html_builder = {
   build_line: function generate_html( colour, text ) {
      if ( ! text ) return "";
      text = irc_to_text( text );
      if ( ! colour ) return text_to_html( text );
      var span = document.createElement('span');
      span.style.color = colour;
      span.appendChild( document.createTextNode( text ) );
      return span.outerHTML;
   }
}

/**
 * Build line in BBCode
 */
var bbc_builder = {
  last_colour : '',
  mark_colour : '',

  open : function generate_bbc_open() {
     this.last_colour = '';
     return "";
  },

  mark: function generate_bbc_mark() {
     this.mark_colour = this.last_colour;
  },

  reset: function generate_bbc_reset() {
     this.last_colour = this.mark_colour;
  },

  build_line: function generate_bbc( colour, text ) {
     if ( ! text ) return "";
     text = irc_to_text( text );
     if ( this.last_colour !== colour ) {
        text = ( this.last_colour ? "[/color]" : "" ) + ( colour ? "[color="+colour+"]" : "" ) + text;
     }
     this.last_colour = colour;
     return text;
  },

  close: function generate_bbc_close() {
     return this.last_colour ? "[/color]" : "";
  }
}

//})();
</script><noscript>
  <h1>Please Enable JavaScript</h1>
  <h1>請啓用 JavaScript</h1>
</noscript>
</body></html>